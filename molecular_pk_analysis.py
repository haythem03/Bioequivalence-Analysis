# -*- coding: utf-8 -*-
"""molecular_pk_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fY6Trst2OZsZnNxhqlMsmm6JctCSxoat
"""

# Molecular Properties and PK Parameter Prediction
# ================================================
# This notebook contains functions for calculating molecular descriptors,
# predicting solubility, and estimating PK parameters from chemical structures

# Install required packages (run once)
#!pip install rdkit pandas numpy

# Import required libraries
import pandas as pd
import numpy as np
from rdkit import Chem
from rdkit.Chem import Descriptors
from rdkit.Chem import rdMolDescriptors
from typing import Dict, Any, Optional

# ==============================================================================
# MOLECULAR DESCRIPTOR FUNCTIONS
# ==============================================================================

def predict_LogS(mol: Chem.Mol) -> float:
    """
    Predict aqueous solubility using Delaney's model.

    LogS = 0.16 - 0.63*logP - 0.0062*MW + 0.066*RB - 0.74*AROM

    Args:
        mol: RDKit molecule object

    Returns:
        Predicted log solubility (LogS)
    """
    if mol is None:
        return None

    logP = Descriptors.MolLogP(mol)
    mw = Descriptors.MolWt(mol)
    rb = Descriptors.NumRotatableBonds(mol)
    aromatic = rdMolDescriptors.CalcNumAromaticRings(mol)

    logS = 0.16 - 0.63*logP - 0.0062*mw + 0.066*rb - 0.74*aromatic
    return round(logS, 3)

def calculate_molecular_descriptors(smiles: str) -> Dict[str, float]:
    """
    Calculate comprehensive molecular descriptors from SMILES string.

    Args:
        smiles: SMILES representation of the molecule

    Returns:
        Dictionary containing molecular descriptors
    """
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            raise ValueError("Invalid SMILES string")

        descriptors = {
            "MW": round(Descriptors.MolWt(mol), 2),
            "LogP": round(Descriptors.MolLogP(mol), 3),
            "PSA": round(Descriptors.TPSA(mol), 2),
            "HBA": Descriptors.NumHAcceptors(mol),
            "HBD": Descriptors.NumHDonors(mol),
            "RotBonds": Descriptors.NumRotatableBonds(mol),
            "AromaticRings": rdMolDescriptors.CalcNumAromaticRings(mol),
            "LogS": predict_LogS(mol)
        }

        return descriptors

    except Exception as e:
        print(f"Error calculating descriptors: {e}")
        return None

# ==============================================================================
# PK PARAMETER ESTIMATION FUNCTIONS
# ==============================================================================

def estimate_base_pk_parameters(descriptors: Dict[str, float], weight_kg: float = 70) -> Dict[str, float]:
    """
    Estimate base PK parameters from molecular descriptors.

    Args:
        descriptors: Dictionary of molecular descriptors
        weight_kg: Body weight in kg

    Returns:
        Dictionary of estimated PK parameters
    """
    if descriptors is None:
        return None

    LogP = descriptors["LogP"]
    PSA = descriptors["PSA"]
    MW = descriptors["MW"]
    HBD = descriptors["HBD"]

    # Absorption rate constant (Ka)
    # Higher LogP and lower PSA typically mean faster absorption
    if LogP > 2 and PSA < 90:
        Ka = 1.3
    elif LogP < 0 or PSA > 140:
        Ka = 0.4
    else:
        Ka = 0.7

    # Clearance (CL)
    # Generally inversely related to molecular weight
    if MW < 300:
        CL = 8.0
    elif MW < 400:
        CL = 6.0
    else:
        CL = 3.0

    # Volume of distribution (Vd)
    # Lipophilic compounds have higher Vd
    if LogP > 3:
        Vd = 1.0 * weight_kg
    elif LogP > 1:
        Vd = 0.7 * weight_kg
    else:
        Vd = 0.5 * weight_kg

    # Oral bioavailability (F)
    # Optimized for oral absorption (Lipinski-like properties)
    if (1 <= LogP <= 3) and (PSA <= 100) and (HBD <= 3):
        F = 0.85
    elif LogP < 0 or PSA > 140 or HBD > 5:
        F = 0.3
    else:
        F = 0.6

    # Lag time (initial)
    Tlag = 0.1

    return {
        "Ka": round(Ka, 3),
        "CL": round(CL, 2),
        "Vd": round(Vd, 1),
        "F": round(F, 2),
        "Tlag": round(Tlag, 2)
    }

def apply_formulation_effects(base_params: Dict[str, float], formulation: Dict[str, Any]) -> Dict[str, float]:
    """
    Apply formulation effects to base PK parameters.

    Args:
        base_params: Base PK parameters
        formulation: Formulation characteristics

    Returns:
        Adjusted PK parameters
    """
    if base_params is None:
        return None

    # Start with base parameters
    adjusted = base_params.copy()

    # Release mechanism effects
    release_mech = formulation.get("release_mechanism", "Immediate Release (IR)")
    if release_mech == "Extended Release (ER)":
        adjusted["Ka"] *= 0.25  # Much slower absorption
        adjusted["Tlag"] += 0.5
    elif release_mech == "Enteric Coated":
        adjusted["Ka"] *= 0.4   # Delayed absorption
        adjusted["Tlag"] += 2.0

    # Solubility class effects
    solubility_class = formulation.get("solubility_class", "High")
    if solubility_class == "Low":
        adjusted["F"] *= 0.5
        adjusted["Ka"] *= 0.7
    elif solubility_class == "Medium":
        adjusted["F"] *= 0.8
        adjusted["Ka"] *= 0.9

    # Fed state effects
    fed_state = formulation.get("fed_state", "Fasted")
    if fed_state == "Fed":
        adjusted["Tlag"] += 0.5
        adjusted["F"] *= 0.9
        adjusted["Ka"] *= 0.8

    # Particle size effects
    particle_size = formulation.get("particle_size_um", 50)
    if particle_size > 100:
        adjusted["Ka"] *= 0.85
        adjusted["F"] *= 0.95
    elif particle_size < 20:
        adjusted["Ka"] *= 1.1
        adjusted["F"] *= 1.05

    # Lag time override
    tlag_override = formulation.get("tlag_override_h", 0)
    if tlag_override > 0:
        adjusted["Tlag"] = tlag_override

    # Round final values
    for key in adjusted:
        adjusted[key] = round(adjusted[key], 3)

    return adjusted

def get_default_formulation() -> Dict[str, Any]:
    """Return default formulation parameters."""
    return {
        "release_mechanism": "Immediate Release (IR)",
        "solubility_class": "High",
        "particle_size_um": 50,
        "fed_state": "Fasted",
        "tlag_override_h": 0.0
    }

# ==============================================================================
# MAIN ANALYSIS FUNCTION
# ==============================================================================

def analyze_compound(smiles: str, formulation: Optional[Dict[str, Any]] = None, weight_kg: float = 70) -> Dict[str, Any]:
    """
    Complete analysis of a compound from SMILES to PK parameters.

    Args:
        smiles: SMILES string
        formulation: Formulation parameters (optional, uses defaults if None)
        weight_kg: Body weight in kg

    Returns:
        Dictionary containing all analysis results
    """
    if formulation is None:
        formulation = get_default_formulation()

    # Calculate molecular descriptors
    descriptors = calculate_molecular_descriptors(smiles)
    if descriptors is None:
        return {"error": "Invalid SMILES or calculation error"}

    # Estimate base PK parameters
    base_pk = estimate_base_pk_parameters(descriptors, weight_kg)

    # Apply formulation effects
    final_pk = apply_formulation_effects(base_pk, formulation)

    return {
        "smiles": smiles,
        "descriptors": descriptors,
        "base_pk_parameters": base_pk,
        "formulation": formulation,
        "final_pk_parameters": final_pk,
        "weight_kg": weight_kg
    }

# ==============================================================================
# EXAMPLE USAGE
# ==============================================================================

def run_example_analysis():
    """Run example analysis with aspirin."""

    print("=" * 60)
    print("MOLECULAR PROPERTIES & PK PARAMETER PREDICTION")
    print("=" * 60)

    # Example: Aspirin
    aspirin_smiles = "CC(=O)OC1=CC=CC=C1C(=O)O"

    print(f"\nAnalyzing: Aspirin")
    print(f"SMILES: {aspirin_smiles}")
    print("-" * 40)

    # Default formulation
    print("\n1. IMMEDIATE RELEASE FORMULATION:")
    result_ir = analyze_compound(aspirin_smiles)

    print("\nMolecular Descriptors:")
    for key, value in result_ir["descriptors"].items():
        print(f"  {key}: {value}")

    print("\nPK Parameters:")
    for key, value in result_ir["final_pk_parameters"].items():
        print(f"  {key}: {value}")

    # Modified formulation
    print("\n2. EXTENDED RELEASE FORMULATION:")
    formulation_er = {
        "release_mechanism": "Extended Release (ER)",
        "solubility_class": "Medium",
        "particle_size_um": 75,
        "fed_state": "Fed",
        "tlag_override_h": 0.0
    }

    result_er = analyze_compound(aspirin_smiles, formulation_er)

    print("\nPK Parameters (ER Formulation):")
    for key, value in result_er["final_pk_parameters"].items():
        print(f"  {key}: {value}")

    # Comparison table
    print("\n3. COMPARISON TABLE:")
    comparison_df = pd.DataFrame({
        'Parameter': ['Ka', 'CL', 'Vd', 'F', 'Tlag'],
        'IR_Formulation': [result_ir["final_pk_parameters"][p] for p in ['Ka', 'CL', 'Vd', 'F', 'Tlag']],
        'ER_Formulation': [result_er["final_pk_parameters"][p] for p in ['Ka', 'CL', 'Vd', 'F', 'Tlag']]
    })

    print(comparison_df.to_string(index=False))

    return result_ir, result_er

# ==============================================================================
# VALIDATION FUNCTION
# ==============================================================================

def validate_smiles(smiles: str) -> bool:
    """
    Validate SMILES string.

    Args:
        smiles: SMILES string to validate

    Returns:
        True if valid, False otherwise
    """
    try:
        mol = Chem.MolFromSmiles(smiles)
        return mol is not None
    except:
        return False

# ==============================================================================
# BATCH PROCESSING FUNCTION
# ==============================================================================

def batch_analyze_compounds(compounds_data: list) -> pd.DataFrame:
    """
    Analyze multiple compounds in batch.

    Args:
        compounds_data: List of dictionaries containing 'smiles' and optionally 'formulation'

    Returns:
        DataFrame with all results
    """
    results = []

    for i, compound in enumerate(compounds_data):
        smiles = compound["smiles"]
        formulation = compound.get("formulation", get_default_formulation())
        name = compound.get("name", f"Compound_{i+1}")

        result = analyze_compound(smiles, formulation)

        if "error" not in result:
            # Flatten the result for DataFrame
            row = {"Name": name, "SMILES": smiles}
            row.update(result["descriptors"])
            row.update({f"PK_{k}": v for k, v in result["final_pk_parameters"].items()})
            results.append(row)
        else:
            print(f"Error analyzing {name}: {result['error']}")

    return pd.DataFrame(results)

# ==============================================================================
# RUN EXAMPLE
# ==============================================================================

if __name__ == "__main__":
    # Run the example analysis
    result_ir, result_er = run_example_analysis()

    # Example of batch processing
    print("\n" + "=" * 60)
    print("BATCH ANALYSIS EXAMPLE")
    print("=" * 60)

    compounds = [
        {
            "name": "Aspirin",
            "smiles": "CC(=O)OC1=CC=CC=C1C(=O)O"
        },
        {
            "name": "Ibuprofen",
            "smiles": "CC(C)CC1=CC=C(C=C1)C(C)C(=O)O"
        },
        {
            "name": "Caffeine",
            "smiles": "CN1C=NC2=C1C(=O)N(C(=O)N2C)C"
        }
    ]

    batch_results = batch_analyze_compounds(compounds)
    print("\nBatch Analysis Results:")
    print(batch_results[['Name', 'MW', 'LogP', 'PSA', 'PK_Ka', 'PK_CL', 'PK_Vd', 'PK_F']].to_string(index=False))

# ==============================================================================
# EXPORT FUNCTIONS FOR R INTEGRATION
# ==============================================================================

def get_pk_parameters_for_r(smiles: str,
                           release_mechanism: str = "Immediate Release (IR)",
                           solubility_class: str = "High",
                           particle_size_um: float = 50,
                           fed_state: str = "Fasted",
                           tlag_override_h: float = 0.0,
                           weight_kg: float = 70) -> Dict[str, Any]:
    """
    Main function for R integration - returns PK parameters for use in R Shiny.

    This function is designed to be called from R using reticulate.

    Args:
        smiles: SMILES string
        release_mechanism: "Immediate Release (IR)", "Extended Release (ER)", "Enteric Coated"
        solubility_class: "High", "Medium", "Low"
        particle_size_um: Particle size in micrometers
        fed_state: "Fasted", "Fed"
        tlag_override_h: Manual lag time override in hours
        weight_kg: Body weight in kg

    Returns:
        Dictionary with descriptors, PK parameters, and validation info
    """

    formulation = {
        "release_mechanism": release_mechanism,
        "solubility_class": solubility_class,
        "particle_size_um": particle_size_um,
        "fed_state": fed_state,
        "tlag_override_h": tlag_override_h
    }

    result = analyze_compound(smiles, formulation, weight_kg)

    if "error" in result:
        return {
            "success": False,
            "error": result["error"]
        }

    return {
        "success": True,
        "descriptors": result["descriptors"],
        "pk_parameters": result["final_pk_parameters"],
        "formulation_used": formulation,
        "base_pk_parameters": result["base_pk_parameters"]
    }

# ==============================================================================
# DRUG-LIKENESS ASSESSMENT
# ==============================================================================

def assess_drug_likeness(descriptors: Dict[str, float]) -> Dict[str, Any]:
    """
    Assess drug-likeness using Lipinski's Rule of Five and other criteria.

    Args:
        descriptors: Molecular descriptors

    Returns:
        Dictionary with drug-likeness assessment
    """
    if descriptors is None:
        return None

    # Lipinski's Rule of Five
    lipinski_violations = 0
    violations = []

    if descriptors["MW"] > 500:
        lipinski_violations += 1
        violations.append("MW > 500")

    if descriptors["LogP"] > 5:
        lipinski_violations += 1
        violations.append("LogP > 5")

    if descriptors["HBD"] > 5:
        lipinski_violations += 1
        violations.append("HBD > 5")

    if descriptors["HBA"] > 10:
        lipinski_violations += 1
        violations.append("HBA > 10")

    # Additional criteria
    psa_ok = descriptors["PSA"] <= 140
    rotbonds_ok = descriptors["RotBonds"] <= 10

    assessment = {
        "lipinski_violations": lipinski_violations,
        "lipinski_compliant": lipinski_violations <= 1,
        "violations_list": violations,
        "psa_compliant": psa_ok,
        "rotatable_bonds_ok": rotbonds_ok,
        "overall_drug_like": (lipinski_violations <= 1) and psa_ok and rotbonds_ok
    }

    return assessment

# ==============================================================================
# COMPREHENSIVE ANALYSIS FUNCTION
# ==============================================================================

def comprehensive_analysis(smiles: str, **kwargs) -> Dict[str, Any]:
    """
    Run comprehensive molecular and PK analysis.

    Args:
        smiles: SMILES string
        **kwargs: Additional parameters for formulation and analysis

    Returns:
        Complete analysis results
    """
    # Get PK parameters
    pk_result = get_pk_parameters_for_r(smiles, **kwargs)

    if not pk_result["success"]:
        return pk_result

    # Add drug-likeness assessment
    drug_likeness = assess_drug_likeness(pk_result["descriptors"])
    pk_result["drug_likeness"] = drug_likeness

    return pk_result

# ==============================================================================
# TESTING SECTION
# ==============================================================================

def test_functions():
    """Test all functions with known compounds."""

    test_compounds = [
        ("Aspirin", "CC(=O)OC1=CC=CC=C1C(=O)O"),
        ("Caffeine", "CN1C=NC2=C1C(=O)N(C(=O)N2C)C"),
        ("Invalid", "INVALID_SMILES")
    ]

    print("Testing Functions:")
    print("-" * 40)

    for name, smiles in test_compounds:
        print(f"\nTesting {name}: {smiles}")

        # Test descriptor calculation
        desc = calculate_molecular_descriptors(smiles)
        if desc:
            print(f"  MW: {desc['MW']}, LogP: {desc['LogP']}")
        else:
            print("  Error in descriptor calculation")

        # Test PK parameter estimation
        pk_result = get_pk_parameters_for_r(smiles)
        if pk_result["success"]:
            print(f"  Ka: {pk_result['pk_parameters']['Ka']}, F: {pk_result['pk_parameters']['F']}")
        else:
            print(f"  Error: {pk_result['error']}")

# Run tests if executed directly
if __name__ == "__main__":
    test_functions()

